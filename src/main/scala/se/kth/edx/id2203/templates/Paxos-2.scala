//{"gradingToken":[45,45,45,45,45,66,69,71,73,78,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10,86,101,114,115,105,111,110,58,32,66,67,80,71,32,118,49,46,53,53,10,10,104,81,73,77,65,57,79,116,77,118,84,69,98,74,49,102,65,82,65,65,112,47,101,90,87,110,107,110,122,84,83,49,108,50,107,72,49,84,56,73,57,85,82,121,120,84,43,108,73,100,48,101,100,51,47,116,50,90,107,76,112,98,83,84,10,57,52,90,89,55,84,65,71,43,86,66,47,102,84,114,122,117,98,89,83,54,120,78,85,89,98,85,75,105,81,98,102,114,116,99,103,82,76,90,52,68,116,111,121,100,116,115,118,121,82,86,49,100,47,76,53,101,68,122,85,89,113,65,89,10,118,106,118,115,84,52,110,99,87,53,79,122,82,65,79,87,51,119,55,78,115,104,122,89,97,76,106,104,100,53,87,113,108,49,97,114,76,53,98,122,84,50,102,105,117,54,98,87,115,81,121,112,102,70,48,117,122,83,65,110,67,48,89,117,10,90,68,82,79,109,57,67,75,111,85,85,84,81,119,79,100,109,82,97,68,114,84,71,109,47,82,97,69,117,57,83,97,85,80,88,85,52,103,47,115,66,114,104,81,78,80,68,68,57,86,51,120,116,122,51,113,100,122,78,84,72,74,110,104,10,105,100,88,98,88,65,67,81,73,69,104,118,100,102,71,118,121,105,77,47,65,77,90,106,79,84,109,116,114,118,56,84,81,102,89,65,47,69,114,57,105,71,47,121,107,83,105,122,81,87,57,72,52,112,112,54,80,49,75,112,107,57,66,86,10,86,68,52,108,77,82,43,69,77,48,119,51,100,116,102,88,82,116,103,65,87,112,115,53,43,47,88,53,78,106,86,74,105,106,90,112,73,100,51,100,86,120,73,86,114,79,119,70,122,56,57,114,120,119,56,47,106,57,67,88,107,76,69,83,10,106,76,57,47,119,100,97,98,50,72,103,84,84,51,98,85,79,112,112,80,49,85,56,81,78,66,107,107,70,104,117,105,53,68,112,43,74,69,87,72,77,77,83,50,111,103,117,66,114,66,85,106,69,69,57,106,76,120,106,107,50,97,49,51,10,121,47,119,68,122,69,84,112,81,106,57,86,68,65,77,106,81,79,69,66,80,67,69,122,113,121,51,117,102,117,104,109,87,85,85,82,53,117,65,110,85,110,43,56,69,56,77,54,82,67,54,88,103,98,52,73,105,76,110,102,50,79,114,116,10,108,121,54,67,70,81,79,111,97,81,107,104,120,67,65,65,72,49,86,77,74,99,104,81,109,83,49,56,88,97,47,76,72,109,83,114,75,52,82,101,122,108,102,107,88,87,85,67,48,80,107,72,78,81,77,111,53,52,86,121,83,75,71,69,10,114,90,117,84,98,107,81,79,65,113,70,65,72,105,122,71,79,77,98,78,66,71,52,103,86,100,107,117,115,48,99,88,65,118,82,80,53,51,89,69,67,98,53,49,72,90,55,110,79,67,84,47,101,72,65,68,71,118,65,89,56,121,119,89,10,105,119,79,121,51,102,103,110,86,112,100,98,82,76,65,67,49,115,110,43,110,86,106,101,73,113,117,103,113,75,105,97,52,47,82,74,109,73,79,101,114,118,69,118,75,116,43,82,109,98,79,51,54,101,65,99,51,55,71,108,52,77,122,83,10,119,69,103,66,66,72,90,101,49,82,89,119,116,118,97,109,57,77,89,80,71,43,121,54,77,112,75,119,79,81,79,100,53,65,79,119,110,99,50,73,103,52,90,104,72,83,80,106,82,108,85,55,108,113,116,90,53,113,110,117,55,119,52,57,10,103,105,47,118,86,70,48,67,99,68,106,82,72,117,115,69,81,80,104,74,68,67,105,67,70,76,81,83,86,52,85,47,106,52,101,117,97,74,84,85,88,81,49,110,90,76,111,121,74,85,80,112,51,107,108,104,118,70,89,43,97,119,106,55,10,108,88,116,104,57,66,65,115,66,67,56,119,67,120,104,118,88,50,99,104,74,71,69,52,114,85,47,85,82,109,97,65,109,77,110,83,112,97,90,72,112,75,55,118,48,99,85,73,90,79,50,55,51,72,100,116,99,71,50,54,90,110,109,68,10,82,106,106,90,77,111,107,118,80,78,75,82,76,101,116,54,78,51,73,66,68,72,88,101,103,88,72,79,65,43,82,102,97,112,76,83,56,97,121,103,120,79,89,74,101,90,43,50,79,66,98,98,83,56,74,78,69,50,86,43,108,47,65,113,10,67,48,73,114,103,79,71,68,65,114,113,113,85,108,111,121,49,47,55,116,76,87,105,49,106,71,75,114,122,107,67,98,55,49,49,79,43,107,98,106,117,115,107,107,73,100,68,116,119,117,54,122,98,117,71,86,114,52,57,118,120,65,83,115,10,69,118,65,112,83,100,65,102,48,97,85,118,88,121,100,68,106,102,99,107,119,122,67,104,118,102,76,68,50,47,65,74,88,88,52,61,10,61,105,118,87,86,10,45,45,45,45,45,69,78,68,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10]}

// ### Distributed Consensus
// In this final programming assignment for Part I of the course you will have to complete the implementation of a variation of the famous Paxos algorithm.

// When you are done you simply have to export your notebook and then upload it in the “Programming Exercise 5” page.

// Things to Remember:
// 1. Basic components such as PerfectLink and Best-Effort Broadcast are already provided. No need to implement them.
// 2. Execute the imports defined below before compiling your component implementations.
// 3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.
// 4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. println(s"Process $self delivers message $msg");
// 5. Remember that during the simulation check you can print and observe the simulation time, i.e. with System.currentTimeMillis().
// 5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied before exporting and submitting the notebook.
// 6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)

// Good luck! :)

package se.kth.edx.id2203.templates

import se.kth.edx.id2203.core.ExercisePrimitives.AddressUtils._
import se.kth.edx.id2203.core.Ports._
import se.kth.edx.id2203.templates.Paxos._
import se.kth.edx.id2203.validation._
import se.sics.kompics.network._
import se.sics.kompics.sl.{ Init, _ }
import se.sics.kompics.{ KompicsEvent, ComponentDefinition => _, Port => _ }
import scala.language.implicitConversions
import scala.collection.mutable.ListBuffer;

// ### Leader-less Obstraction-Free Paxos for Single Value Consensus
// A (single value) Consensus Abstraction, in Kompics terms, is a component that provides the following port (already imported in the notebook).

//  class Consensus extends Port{
//    request[C_Propose];
//    indication[C_Decide];
//  }

// An Consensus component should request value proposals (C_Propose) and respond with decided value events (C_Decide) respectively as defined below:

//  case class C_Decide(value: Any) extends KompicsEvent;
//  case class C_Propose(value: Any) extends KompicsEvent;

// The following properties define the expected behavior of a consensus abstraction more specifically:

// 1. Validity: Only proposed values may be decided.
// 2. Uniform Agreement: No two nodes decide different values.
// 3. Integrity: Each node can decide a value at most once.
// 4. Termination: Every node eventually decides a value.


// The recommended algorithm to use is the the one we call “Leaderless Repeatable Paxos” which initiates new proposal rounds until a decision has been made.
// You can find the algorithm in the following document (pages 2-3): https://canvas.kth.se/courses/37639/files/6036181?wrap=1
object Paxos {

  case class Prepare(proposalBallot: (Int, Int)) extends KompicsEvent;
  case class Promise(promiseBallot: (Int, Int), acceptedBallot: (Int, Int), acceptedValue: Option[Any]) extends KompicsEvent;
  case class Accept(acceptBallot: (Int, Int), proposedValue: Any) extends KompicsEvent;
  case class Accepted(acceptedBallot: (Int, Int)) extends KompicsEvent;
  case class Nack(ballot: (Int, Int)) extends KompicsEvent;
  case class Decided(decidedValue: Any) extends KompicsEvent;

  /**
   * This augments tuples with comparison operators implicitly, which you can use in your code, for convenience.
   * examples: (1,2) > (1,4) yields 'false' and  (5,4) <= (7,4) yields 'true'
   */
  implicit def addComparators[A](x: A)(implicit o: math.Ordering[A]): o.OrderingOps = o.mkOrderingOps(x);
  //HINT: After you execute the latter implicit ordering you can compare tuples as such within your component implementation:
  // (1,2) <= (1,4);

}

class Paxos(paxosInit: Init[Paxos]) extends ComponentDefinition {

  //Port Subscriptions for Paxos
  val consensus = provides[Consensus];
  val beb = requires[BestEffortBroadcast];
  val plink = requires[PerfectLink];

  //Internal State of Paxos
  val (rank, numProcesses) = paxosInit match {
    case Init(s: Address, qSize: Int) => (toRank(s), qSize)
  }
  
  // Calculate majority properly
  val majority = (numProcesses / 2) + 1;

  //Proposer State
  var round = 0; //ts
  var proposedValue: Option[Any] = None; //pv
  var promises: ListBuffer[((Int, Int), Option[Any])] = ListBuffer.empty; // promises
  var numOfAccepts = 0; //numOfAccepts
  var decided = false; // decided

  //Acceptor State
  var promisedBallot = (0, 0); //promBallot
  var acceptedBallot = (0, 0); //accBallot
  var acceptedValue: Option[Any] = None; //av

  def propose() = {
    /* 
   INSERT YOUR CODE HERE 
   */
    if (!decided) {
      round = round + 1;
      numOfAccepts = 0;
      promises.clear();
      trigger(BEB_Broadcast(Prepare((round, rank))) -> beb);
    }
  }

  consensus uponEvent {
    case C_Propose(value) => {
      /* 
      INSERT YOUR CODE HERE 
      */
      proposedValue = Some(value);
      propose();
    }
  }

  beb uponEvent {

    case BEB_Deliver(src, prep: Prepare) => {
      /* 
      INSERT YOUR CODE HERE 
      */
      if (promisedBallot < prep.proposalBallot) {
        promisedBallot = prep.proposalBallot;
        trigger(PL_Send(src, Promise(promisedBallot, acceptedBallot, acceptedValue)) -> plink);
      } else {
        trigger(PL_Send(src, Nack(prep.proposalBallot)) -> plink);
      }
    };

    case BEB_Deliver(src, acc: Accept) => {
      /* 
      INSERT YOUR CODE HERE 
      */
      if (promisedBallot <= acc.acceptBallot) {
        promisedBallot = acc.acceptBallot;
        acceptedBallot = acc.acceptBallot;
        acceptedValue = Some(acc.proposedValue);
        trigger(PL_Send(src, Accepted(acceptedBallot)) -> plink);
      } else {
        trigger(PL_Send(src, Nack(acc.acceptBallot)) -> plink);
      }
    };

    case BEB_Deliver(src, dec: Decided) => {
      /* 
      INSERT YOUR CODE HERE 
      */
      if (!decided) {
        decided = true;
        trigger(C_Decide(dec.decidedValue) -> consensus);
      }
    }
  }

  plink uponEvent {

    case PL_Deliver(src, prepAck: Promise) => {
      if ((round, rank) == prepAck.promiseBallot) {
        /* 
        INSERT YOUR CODE HERE 
        */
        promises += ((prepAck.acceptedBallot, prepAck.acceptedValue))
        if (promises.size == majority) {
          var highestBallot = (0, 0)
          var highestValue: Option[Any] = None
          
          for ((ballot, value) <- promises) {
            if (value.isDefined && ballot > highestBallot) {
              highestBallot = ballot
              highestValue = value
            }
          }
          
          if (highestValue.isDefined) {
            proposedValue = highestValue
          }
          
          if (proposedValue.isDefined) {
            trigger(BEB_Broadcast(Accept((round, rank), proposedValue.get)) -> beb)
          }
        }
      }
    };

    case PL_Deliver(src, accAck: Accepted) => {
      if ((round, rank) == accAck.acceptedBallot) {
        /* 
        INSERT YOUR CODE HERE 
        */
        numOfAccepts = numOfAccepts + 1;
        if (numOfAccepts == majority) {
          if (proposedValue.isDefined) {
            trigger(BEB_Broadcast(Decided(proposedValue.get)) -> beb);
          }
        }
      }
    };

    case PL_Deliver(src, nack: Nack) => {
      if ((round, rank) == nack.ballot) {
        /* 
        INSERT YOUR CODE HERE 
        */
        propose();
      }
    }
  }

};

object PaxosTemplate extends App {
  checkSingleValueConsensus[Paxos]();
}
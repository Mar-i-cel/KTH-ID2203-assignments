//{"gradingToken":[45,45,45,45,45,66,69,71,73,78,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10,86,101,114,115,105,111,110,58,32,66,67,80,71,32,118,49,46,53,53,10,10,104,81,73,77,65,57,79,116,77,118,84,69,98,74,49,102,65,81,47,43,75,104,51,76,56,112,119,53,90,71,88,107,53,67,115,121,56,110,86,87,55,89,113,68,119,103,88,108,122,89,78,116,71,109,89,47,83,107,43,109,101,57,66,73,10,67,86,67,65,120,79,70,119,103,122,49,114,70,53,109,57,75,71,75,52,50,113,72,88,107,101,80,78,122,86,109,99,75,76,85,90,69,86,66,52,67,108,107,67,120,89,121,51,112,84,99,100,66,105,121,89,104,108,65,105,77,80,67,97,10,57,77,57,48,65,111,72,104,52,119,116,101,67,114,117,81,79,77,106,103,98,114,76,73,102,87,99,43,77,121,99,69,122,119,75,79,108,115,69,48,73,56,116,83,116,51,66,71,121,69,48,48,54,122,100,69,100,51,107,53,73,55,77,68,10,113,100,51,119,85,111,49,71,80,77,75,80,74,79,49,47,57,72,104,118,70,109,88,65,116,99,56,98,97,72,53,68,69,100,100,67,89,50,107,69,51,85,104,114,73,105,101,86,119,78,114,72,97,77,72,85,117,103,85,115,69,48,54,86,10,78,112,108,97,84,114,106,74,121,117,72,67,103,68,53,108,84,81,73,74,121,79,100,84,88,121,67,97,89,81,111,55,43,109,103,117,102,48,47,88,48,102,112,100,72,52,77,55,68,57,50,106,57,82,43,49,51,107,120,54,87,80,114,80,10,57,49,85,89,103,113,52,90,70,114,122,68,90,84,57,56,121,71,54,51,69,87,68,101,66,122,76,86,119,70,83,71,77,70,65,84,71,78,55,50,70,66,68,110,52,99,67,56,88,57,88,74,106,106,104,104,112,115,53,86,67,111,66,71,10,104,57,85,122,114,102,75,103,117,122,107,109,116,50,56,101,104,75,43,57,79,80,72,111,49,78,118,50,76,43,77,54,102,54,108,82,85,106,78,104,90,72,121,71,108,101,79,69,86,86,84,66,70,100,118,51,109,84,107,57,89,111,47,78,10,49,113,86,68,82,65,87,84,82,50,71,53,54,110,117,87,88,104,52,114,101,78,88,52,72,55,105,112,111,113,113,116,67,97,90,112,110,119,66,74,86,122,116,99,78,102,87,79,54,116,99,80,99,111,103,84,115,110,53,116,55,113,83,98,10,119,81,100,113,103,101,99,73,43,104,113,105,122,97,50,81,65,72,51,43,117,107,116,82,66,73,48,51,79,53,47,77,49,48,75,48,53,86,108,99,112,113,52,100,89,51,51,70,112,114,84,113,43,85,120,112,97,56,55,120,83,117,111,97,10,102,54,53,81,82,78,69,116,116,119,71,77,87,70,72,110,78,43,67,89,120,75,84,71,118,103,80,106,73,74,84,98,51,74,74,56,77,77,119,81,77,86,55,68,75,47,107,114,90,98,52,81,56,100,47,120,81,47,97,90,57,81,111,83,10,101,83,115,75,118,55,77,50,103,105,104,56,114,48,80,98,106,53,65,69,105,84,101,97,48,81,48,114,88,109,90,114,104,47,52,99,48,97,72,117,111,122,99,66,107,102,71,74,118,118,82,105,112,76,102,88,74,105,112,98,90,50,106,83,10,119,67,81,66,102,80,115,113,80,118,111,110,51,112,107,103,110,73,70,114,71,103,101,110,69,71,109,109,105,71,51,79,114,81,102,65,118,86,89,85,106,107,88,48,72,99,57,115,118,54,56,122,109,51,56,105,110,112,56,51,70,97,88,105,10,50,115,56,119,122,65,105,97,73,105,117,114,101,84,111,56,113,110,75,78,77,75,65,108,114,98,73,119,49,112,79,116,109,108,78,121,115,84,86,67,55,52,117,48,76,70,47,54,54,119,66,86,117,103,114,120,83,101,117,77,116,121,53,102,10,57,90,99,98,88,57,120,81,120,86,116,104,83,84,80,86,49,70,113,56,57,78,83,67,99,85,105,106,84,53,53,107,112,103,112,78,83,100,102,106,103,105,89,102,48,76,51,83,56,82,56,77,70,101,120,110,55,112,120,79,48,88,111,52,10,101,68,115,112,75,49,74,119,108,75,67,80,121,122,115,121,72,114,69,120,102,57,107,118,81,56,74,122,117,115,48,69,53,54,49,86,82,49,118,53,103,82,118,56,114,72,87,116,118,84,89,99,111,67,101,119,84,119,103,82,81,107,109,69,10,66,79,98,70,83,75,74,49,97,121,107,105,48,120,73,82,51,56,114,70,117,76,105,122,115,48,90,47,121,71,68,109,52,68,101,74,107,55,65,75,104,114,115,113,81,89,105,113,65,111,115,61,10,61,104,57,122,119,10,45,45,45,45,45,69,78,68,32,80,71,80,32,77,69,83,83,65,71,69,45,45,45,45,45,10]}

// ### Exercise 1: Build an Eventually Perfect Failure Detector
//
// An Eventually Perfect Failure Detector (EPFD), in Kompics terms, is a component that **provides** the following port _(already imported in the code)_.
//
//```scala
//  class EventuallyPerfectFailureDetector extends Port {
//    indication[Suspect];
//    indication[Restore];
//  }
//```
//
// Simply put, your component should indicate or ‘deliver’ to the application the following messages:
//
//```scala
//  case class Suspect(src: Address) extends KompicsEvent;
//  case class Restore(src: Address) extends KompicsEvent;
//```
//
// As you have already learnt from the course lectures, an EPFD, defined in a partially synchronous model, should satisfy the following properties:
//
//  1.  **Completeness**: Every process that crashes should be eventually suspected permanently by every correct process
//  2.  **Eventual Strong Accuracy**: No correct process should be eventually suspected by any other correct process
//
// To complete this assignment you will have to fill in the missing functionality denoted by the commented sections below and pass the property checking test at the end of this notebook.  
// The recommended algorithm to use in this assignment is _EPFD with Increasing Timeout and Sequence Numbers_, which you can find at the second page of this [document](https://courses.edx.org/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block@epfd.pdf) in the respective lecture.

package se.kth.edx.id2203.templates

import se.kth.edx.id2203.core.Ports._
import se.kth.edx.id2203.templates.EPFD._
import se.kth.edx.id2203.validation._
import se.sics.kompics.network._
import se.sics.kompics.sl.{ Init, _ }
import se.sics.kompics.timer.{ ScheduleTimeout, Timeout, Timer }
import se.sics.kompics.{ KompicsEvent, Start, ComponentDefinition => _, Port => _ }

import scala.collection.mutable._

//Define initialization event
object EPFD {

  //Declare custom message types related to internal component implementation
  case class CheckTimeout(timeout: ScheduleTimeout) extends Timeout(timeout);

  case class HeartbeatReply(seq: Int) extends KompicsEvent;
  case class HeartbeatRequest(seq: Int) extends KompicsEvent;
}

//Define EPFD Implementation
class EPFD(epfdInit: Init[EPFD]) extends ComponentDefinition {

  //EPFD subscriptions
  val timer = requires[Timer];
  val pLink = requires[PerfectLink];
  val epfd = provides[EventuallyPerfectFailureDetector];

  // EPDF component state and initialization
  val self = epfdInit match {
    case Init(s: Address) => s
  }

  val topology = cfg.getValue[List[Address]]("epfd.simulation.topology");
  val delta = cfg.getValue[Long]("epfd.simulation.delay");

  var period = cfg.getValue[Long]("epfd.simulation.delay");
  var alive = Set(cfg.getValue[List[Address]]("epfd.simulation.topology"): _*);
  var suspected = Set[Address]();
  var seqnum = 0;

  def startTimer(delay: Long): Unit = {
    val scheduledTimeout = new ScheduleTimeout(period);
    scheduledTimeout.setTimeoutEvent(CheckTimeout(scheduledTimeout));
    trigger(scheduledTimeout -> timer);
  }

  //EPFD event handlers
  ctrl uponEvent {
    case _: Start => {
      /* WRITE YOUR CODE HERE */
      startTimer(period)
    }
  }

  timer uponEvent {
    case CheckTimeout(_) => {
      if (!alive.intersect(suspected).isEmpty) {
        /* WRITE YOUR CODE HERE */
        period = period + delta;
      }

      seqnum = seqnum + 1;

      for (p <- topology) {
        if (!alive.contains(p) && !suspected.contains(p)) {
         /* WRITE YOUR CODE HERE */
         suspected = suspected + p;
         trigger(Suspect(p) -> epfd);

        } else if (alive.contains(p) && suspected.contains(p)) {
          suspected = suspected - p;
          trigger(Restore(p) -> epfd);
        }
        trigger(PL_Send(p, HeartbeatRequest(seqnum)) -> pLink);
      }

      alive = Set[Address]();
      startTimer(period);
    }
  }


  pLink uponEvent {
    case PL_Deliver(src, HeartbeatRequest(seq)) => {
         /* WRITE YOUR CODE HERE */
         trigger(PL_Send(src, HeartbeatReply(seq)) -> pLink);
    }
    case PL_Deliver(src, HeartbeatReply(seq)) => {
        //alive = alive + src
         /* WRITE YOUR CODE HERE */
         if (seq == seqnum) {
            alive = alive + src
        }
    }
  }
};

object EPFDTemplate extends App {
  checkEPFD[EPFD]();
}